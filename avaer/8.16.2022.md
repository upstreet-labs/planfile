- adaptive tone mapping pass debugging (black render target in the passes). the problem was actually in the main webaverse render pass lacking a swap, causing the next pass to scribble over the source framebuffer when using a blur kernel
  - spector.js helped a lot to debug this! you can see that the pass framebuffer is destroyed by the next pass
  - ![image](https://user-images.githubusercontent.com/6926057/184946902-6053b12d-facb-4ed9-822e-3d203a93ea08.png)
- adjusted DOF/Bokeh constants to blur in the hundreds of meters, which is a typical scene depth
- reset pass shaders to three.js upstream, since we don't need reconstruction hacks for log depth buffer anymore
- research stable diffusion weights pull, so that we can deploy a hosted version of the image synthesis. this will probably replace dalle-mini since it's worlds better in terms of quality
- do not generate mipmaps for main render target, for performance
- rewrite Unreal bloom pass to do custom addition in the shader
- bugfix three-vrm incorrect `this` binding that was causing undefined parent reference during `three-vrm` `VRMSpringBone` `updateMatrixWorld`
- do not dynamically load default metaverse modules, and patch downstream dependencies -- this defers most of the loading and decreases load time. it is also mostly a pure win, since most of these modules were not used. the tradeoff is a slight load time increase when they are first used.
- add missing encoding fragment to avatar renderer (placeholder icon)
- found a frame-sync tilde grab bug
- found a microphone phoneme/avatar grunt phoneme conflict bug (they seem to fight for the volume setting)
- rewrite stacks app to separate loading and initialization. before, it was a massive interleaved jumble of async, sync, and 3d maths code with race conditions that sometimes caused the sakura tree model not to load -- and I didn't even notice this in all of 2 years it was deployed! this code written as a hack demo in like a day (I don't care to check git), and although it was not good, it was only superficially so, and I fixed it in 15 mins. though I don't remember the person who wrote that app, I think I always understood that well factored code is code that can be turned beautiful with mechanical copy pasta + wrapping, and that's exactly what happened here. if the thread of your logic is strongly consistent and isolated, refactoring is a mechanical process. it's so mechanical that we will soon have AIs that do it for us. and I remain convinced that JavaScript is a great language to code game logic with, becasue even though you can shoot yourself in the foot easily, you can also reify a new cyborg foot anytime. and you can bake your code into proper checked typescript when you're done prototyping, on a per-file basis. <3 JS